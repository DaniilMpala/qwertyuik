#include <iostream>
using namespace std;
//Необходимо просмотреть текущую перестановку справа налево и при этом следить за тем, чтобы каждый следующий элемент перестановки(элемент с большим номером)
//был не более чем предыдущий(элемент с меньшим номером).Как только данное соотношение будет нарушено необходимо остановиться и отметить текущее число(позиция 1).
//
//Снова просмотреть пройденный путь справа налево пока не дойдем до первого числа, которое больше чем отмеченное на предыдущем шаге.
//
//Поменять местами два полученных элемента.
//
//Теперь в части массива, которая размещена справа от позиции 1 надо отсортировать все числа в порядке возрастания.Поскольку до этого 
//они все были уже записаны в порядке убывания необходимо эту часть подпоследовательность просто перевернуть.
int sovpadenie = 0;

void swap(int* a, int i, int j)
{
    int s = a[i];
    a[i] = a[j];
    a[j] = s;
}
void check(int* a, int n)  // Совпало или нет
{
    for (int i = 0; i < n; i++)
        if (a[i] == i + 1) {
            sovpadenie++;
            break;
        }
            
}
bool perestanovka(int* a, int n)
{
    int j = n - 2;
    while (j != -1 && a[j] >= a[j + 1])
        j--;
    if (j == -1)
        return false; // больше перестановок нет
                      // у нас перевернулся весь массив
                      // считает сколько кроме ласт 2 значений стоят поочереди
                      // как только
    int k = n - 1;

    while (a[j] >= a[k])//ищем число больше найденное чтобы поеменять местами их и пойти дальше
        k--;

    swap(a, j, k);

    int l = j + 1,
        r = n - 1;// сортируем оставшуюся часть последовательности
    
    while (l < r)//так как мы нашли число в прошлом while и поменяли выровним массив в порядке возрастания и продолжим операцию 
        swap(a, l++, r--);

    return true;
}

int main()
{
    int const n = 10;
    int a[n];

    for (int i = 0; i < n; i++)//заполним массив
        a[i] = i + 1;

    sovpadenie++;//ибо первая строка всегда сойдется

    while (perestanovka(a, n))
        check(a, n);

    cout << sovpadenie;
    return 0;
}
//1: 1 2 4 3 5
//2 : 1 2 4 5 3
//3 : 1 2 5 3 4
//4 : 1 2 5 4 3
//5 : 1 3 2 4 5
//6 : 1 3 2 5 4
//7 : 1 3 4 2 5
//8 : 1 3 4 5 2
//9 : 1 3 5 2 4
//10 : 1 3 5 4 2
//11 : 1 4 2 3 5
//12 : 1 4 2 5 3
//13 : 1 4 3 2 5
//14 : 1 4 3 5 2
//15 : 1 4 5 2 3
//16 : 1 4 5 3 2
//17 : 1 5 2 3 4
//18 : 1 5 2 4 3
//19 : 1 5 3 2 4
//20 : 1 5 3 4 2
//21 : 1 5 4 2 3
//22 : 1 5 4 3 2
//23 : 2 1 3 4 5
//24 : 2 1 3 5 4
//25 : 2 1 4 3 5
//26 : 2 1 4 5 3
//27 : 2 1 5 3 4
//28 : 2 1 5 4 3
//29 : 2 3 1 4 5
//30 : 2 3 1 5 4
//31 : 2 3 4 1 5
//32 : 2 3 4 5 1
//33 : 2 3 5 1 4
//34 : 2 3 5 4 1
//35 : 2 4 1 3 5
//36 : 2 4 1 5 3
//37 : 2 4 3 1 5
//38 : 2 4 3 5 1
//39 : 2 4 5 1 3
//40 : 2 4 5 3 1
//41 : 2 5 1 3 4
//42 : 2 5 1 4 3
//43 : 2 5 3 1 4
//44 : 2 5 3 4 1
//45 : 2 5 4 1 3
//46 : 2 5 4 3 1
//47 : 3 1 2 4 5
//48 : 3 1 2 5 4
//49 : 3 1 4 2 5
//50 : 3 1 4 5 2
//51 : 3 1 5 2 4
//52 : 3 1 5 4 2
//53 : 3 2 1 4 5
//54 : 3 2 1 5 4
//55 : 3 2 4 1 5
//56 : 3 2 4 5 1
//57 : 3 2 5 1 4
//58 : 3 2 5 4 1
//59 : 3 4 1 2 5
//60 : 3 4 1 5 2
//61 : 3 4 2 1 5
//62 : 3 4 2 5 1
//63 : 3 4 5 1 2
//64 : 3 4 5 2 1
//65 : 3 5 1 2 4
//66 : 3 5 1 4 2
//67 : 3 5 2 1 4
//68 : 3 5 2 4 1
//69 : 3 5 4 1 2
//70 : 3 5 4 2 1
//71 : 4 1 2 3 5
//72 : 4 1 2 5 3
//73 : 4 1 3 2 5
//74 : 4 1 3 5 2
//75 : 4 1 5 2 3
//76 : 4 1 5 3 2
//77 : 4 2 1 3 5
//78 : 4 2 1 5 3
//79 : 4 2 3 1 5
//80 : 4 2 3 5 1
//81 : 4 2 5 1 3
//82 : 4 2 5 3 1
//83 : 4 3 1 2 5
//84 : 4 3 1 5 2
//85 : 4 3 2 1 5
//86 : 4 3 2 5 1
//87 : 4 3 5 1 2
//88 : 4 3 5 2 1
//89 : 4 5 1 2 3
//90 : 4 5 1 3 2
//91 : 4 5 2 1 3
//92 : 4 5 2 3 1
//93 : 4 5 3 1 2
//94 : 4 5 3 2 1
//95 : 5 1 2 3 4
//96 : 5 1 2 4 3
//97 : 5 1 3 2 4
//98 : 5 1 3 4 2
//99 : 5 1 4 2 3
//100 : 5 1 4 3 2
//101 : 5 2 1 3 4
//102 : 5 2 1 4 3
//103 : 5 2 3 1 4
//104 : 5 2 3 4 1
//105 : 5 2 4 1 3
//106 : 5 2 4 3 1
//107 : 5 3 1 2 4
//108 : 5 3 1 4 2
//109 : 5 3 2 1 4
//110 : 5 3 2 4 1
//111 : 5 3 4 1 2
//112 : 5 3 4 2 1
//113 : 5 4 1 2 3
//114 : 5 4 1 3 2
//115 : 5 4 2 1 3
//116 : 5 4 2 3 1
//117 : 5 4 3 1 2
//118 : 5 4 3 2 1
//119 : 5 4 3 1 2
//120 : 5 4 3 2 1